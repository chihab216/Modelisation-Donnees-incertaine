---
title: "R Notebook"
output: html_notebookh
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. 

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Ctrl+Shift+Enter*. 

```{r}
install.packages("dplyr")
install.packages("readr")
install.packages("irr")
```

```{r}
#on charge les données
library(dplyr)
library(readr)

MesureMatelas1 <- read.csv("C:/Users/Lenovo/Desktop/mesures_corrige(1).csv", stringsAsFactors = F, dec=".")
##"C:/Users/Lenovo/Desktop/mesuresj1.csv"sep=";","C:/Users/Lenovo/Desktop/mesures.csv"

MesureMatelas2<- read.csv("C:/Users/Lenovo/Desktop/mesuresj1_corrige (1).csv", stringsAsFactors = F,  dec=".")
##on converti toute les valeurs en numeric
MesureMatelas1$intmes3j0 <- as.numeric(MesureMatelas1$intmes3j0)
MesureMatelas1$intmes2j0 <- as.numeric(MesureMatelas1$intmes2j0)
MesureMatelas1$intmes4j0 <- as.numeric(MesureMatelas1$intmes4j0)
MesureMatelas1$intmes1j0 <- as.numeric(MesureMatelas1$intmes1j0)

MesureMatelas2$intmes3j1 <- as.numeric(MesureMatelas2$intmes3j1)
MesureMatelas2$intmes2j1 <- as.numeric(MesureMatelas2$intmes2j1)
MesureMatelas2$intmes4j1 <- as.numeric(MesureMatelas2$intmes4j1)
MesureMatelas2$intmes1j1 <- as.numeric(MesureMatelas2$intmes1j1)

```

```{r}
##Modélisation en trapèze
library(irr)
##on enleve les patients qui ont abandonné le jour2 dans les données du jour1
MesureMatelas1bis=MesureMatelas1[-c(32,54,58),]
x1=c(MesureMatelas1bis$intmes1j0[(MesureMatelas1bis$matelasj0==1)],MesureMatelas2$intmes1j1[(MesureMatelas2$matelasj1==1)])  

x2=c(MesureMatelas1bis$intmes2j0[(MesureMatelas1bis$matelasj0==1)],MesureMatelas2$intmes2j1[(MesureMatelas2$matelasj1==1)])

y1=c(MesureMatelas1bis$intmes1j0[(MesureMatelas1bis$matelasj0==2)],MesureMatelas2$intmes1j1[(MesureMatelas2$matelasj1==2)])  

y2=c(MesureMatelas1bis$intmes2j0[(MesureMatelas1bis$matelasj0==2)],MesureMatelas2$intmes2j1[(MesureMatelas2$matelasj1==2)])
#x1=matelas1 mesure1 ,x2=matelas1 mesure2,y1=matelas2 mesure1 et y2=matelas2 mesure1
df1=data.frame(x1,x2,y1,y2)
####Données apparaié donc on enlève tous les NA
MesureD0 <- na.omit(df1)
#On fait de meme pour le dosseret à 30°
a1=c(MesureMatelas1bis$intmes3j0[(MesureMatelas1bis$matelasj0==1)],MesureMatelas2$intmes3j1[(MesureMatelas2$matelasj1==1)])  

a2=c(MesureMatelas1bis$intmes4j0[(MesureMatelas1bis$matelasj0==1)],MesureMatelas2$intmes4j1[(MesureMatelas2$matelasj1==1)])

b1=c(MesureMatelas1bis$intmes3j0[(MesureMatelas1bis$matelasj0==2)],MesureMatelas2$intmes3j1[(MesureMatelas2$matelasj1==2)])  

b2=c(MesureMatelas1bis$intmes4j0[(MesureMatelas1bis$matelasj0==2)],MesureMatelas2$intmes4j1[(MesureMatelas2$matelasj1==2)])

df2=data.frame(x1=a1,x2=a2,y1=b1,y2=b2)
MesureD30 <- na.omit(df2)
c=100
##fonction qui renvoi les 4 valeurs du trapèze
trapeze<- function(l,m){
  listetr=c()
  listea=c()
  listeb=c()
  listea1=c()
  listeb1=c()
  iccc=icc(cbind(l,m))$value#on prend la valeur de l'icc
  for (i in 1:length(l)){
    ecart=c*(1-iccc)/((abs(l[i]-m[i]))+1)#la valeur que l'on va ajouter à droite et à gauche pour faire un trapèze
    a=min(l[i],m[i])
    b=max(l[i],m[i])
    a1=a-ecart
    b1=b+ecart
    listea=c(listea,a)
    listeb=c(listeb,b)
    listea1=c(listea1,a1)
    listeb1=c(listeb1,b1)
  }
  listetr=cbind(listea1,listea,listeb,listeb1)
  return(listetr)
}
##fonction qui donne les valeurs de trapeze(x)
mu<- function(l,x){
  if(l[1]<=x && x<=l[2]){
    return((x-l[1])/(l[2]-l[1]))
  }
  else if(l[2]<=x && x<=l[3]){
    return(1)
  }
  else if(l[3]<=x && x<=l[4]){
    return((x-l[4])/(l[3]-l[4]))
  }
  else{
    return(0)
    
  }
}
  
trapezematelas1D0=trapeze(MesureD0$x1,MesureD0$x2)

trapezematelas2D0=trapeze(MesureD0$y1,MesureD0$y2)

trapezematelas1D30=trapeze(MesureD30$x1,MesureD30$x2)

trapezematelas2D30=trapeze(MesureD30$y1,MesureD30$y2)



```

```{r}
#Modèle de la moyenne
moyenneMatelas1D0=(MesureD0$x1+MesureD0$x2)/2
moyenneMatelas2D0=(MesureD0$y1+MesureD0$y2)/2
moyenneMatelas1D30=(MesureD30$x1+MesureD30$x2)/2
moyenneMatelas2D30=(MesureD30$y1+MesureD30$y2)/2
t.test(moyenneMatelas1D0, moyenneMatelas2D0, paired=TRUE,alternative= "greater")
t.test(moyenneMatelas1D30, moyenneMatelas2D30, paired=TRUE,alternative= "greater")

```

```{r}
wilcox.test(moyenneMatelas1D0,moyenneMatelas2D0,alternative="greater",paired=TRUE)
wilcox.test(moyenneMatelas1D30,moyenneMatelas2D30,alternative="greater",paired=TRUE)


```

```{r}
##fonction qui transforme des trapèzes en triangle
triangle<- function(l){

 m=(l[,2]+l[,3]/2)#on prend la moyenne des deux valeurs au milieux du trapèze
 k=cbind(l[,1],m,l[,4])
 return(k)
    
}
trianglematelas2D30=triangle(trapezematelas2D30)
trianglematelas1D30=triangle(trapezematelas1D30)
trianglematelas2D0=triangle(trapezematelas2D0)
trianglematelas1D0=triangle(trapezematelas1D0)

```

```{r}
##Intervalle
##on calcule les écarts moyens entre mesure1 et mesure2 pour chaque matelas et position
ecartMoyenm1D0=mean(abs(MesureD0$x1-MesureD0$x2))/2
ecartMoyenm2D0=mean(abs(MesureD0$y1-MesureD0$y2))/2
ecartMoyenm2D30=mean(abs(MesureD30$y1-MesureD30$y2))/2
ecartMoyenm1D30=mean(abs(MesureD30$x1-MesureD30$x2))/2
##on met les données par paire
interM1D0=cbind(MesureD0$x1,MesureD0$x2)
##on met les plus petit en premier et on additionne et soustrait l'écart moyen
for (i in 1:length(MesureD0$x1)){
  if(interM1D0[i,][1]>interM1D0[i,][2]){
    a=interM1D0[i,][1]
    interM1D0[i,][1]=interM1D0[i,][2]
    interM1D0[i,][2]=a
  }
  interM1D0[i,][1]=interM1D0[i,][1]-ecartMoyenm1D0
  interM1D0[i,][2]=interM1D0[i,][2]+ecartMoyenm1D0

}

interM2D0=cbind(MesureD0$y1,MesureD0$y2)
##on met les plus petit en premier
for (i in 1:length(MesureD0$y1)){
  if(interM2D0[i,][1]>interM2D0[i,][2]){
    a=interM2D0[i,][1]
    interM2D0[i,][1]=interM2D0[i,][2]
    interM2D0[i,][2]=a
  }
  interM2D0[i,][1]=interM2D0[i,][1]-ecartMoyenm2D0
  interM2D0[i,][2]=interM2D0[i,][2]+ecartMoyenm2D0
}
interM1D30=cbind(MesureD30$x1,MesureD30$x2)
##on met les plus petit en premier
for (i in 1:length(MesureD30$x1)){
  if(interM1D30[i,][1]>interM1D30[i,][2]){
    a=interM1D30[i,][1]
    interM1D30[i,][1]=interM1D30[i,][2]
    interM1D30[i,][2]=a
  }
  interM1D30[i,][1]=interM1D30[i,][1]-ecartMoyenm1D30
  interM1D30[i,][2]=interM1D30[i,][2]+ecartMoyenm1D30
}
interM2D30=cbind(MesureD30$y1,MesureD30$y2)
##on met les plus petit en premier
for (i in 1:length(MesureD30$y1)){
  if(interM2D30[i,][1]>interM2D30[i,][2]){
    a=interM2D30[i,][1]
    interM2D30[i,][1]=interM2D30[i,][2]
    interM2D30[i,][2]=a
  }
  interM2D30[i,][1]=interM2D30[i,][1]-ecartMoyenm2D30
  interM2D30[i,][2]=interM2D30[i,][2]+ecartMoyenm2D30
}

```

```{r}
##test de wilkoxon rank intervalle denoeux matelas à 0°

n=length(interM1D0[,1])
m=length(interM2D0[,1])
l=n+m
wh=0
ph=1
zh=c(interM1D0[,2],interM2D0[,1])
zh=sort(zh)
interM2D0[,1] = sort(interM2D0[,1])

for(i in 1:l){
   
  if (zh[i]==interM2D0[,1][ph] && ph<=length(interM2D0[,1])){
    ph=ph+1
    
  }
 
  else{
    wh=wh+i
  }
  
}

z=c(interM1D0[,1],interM2D0[,2])
z=sort(z)
interM1D0[,1]=sort(interM1D0[,1])
w=0
q=1
for(j in 1:l){{
  
  if (interM1D0[,1][q]==z[j] && q<=length(interM1D0[,1])){
    q=q+1
    w=w+j
  }
  }
}

nu=n*(n+m+1)/2
s2=n*m*(n+m+1)/12
tbas=(w-nu)/sqrt(s2)
thaut=(wh-nu)/sqrt(s2)
val=max(thaut,-tbas)
val2=max(0,-thaut,tbas)
pbas=2*(1-pnorm(val))
phaut=2*(1-pnorm(val2))
w
wh
nu
s2
tbas
thaut
val
val2
pbas
phaut
```

```{r}
##test de wilkoxon rank intervalle denoeux matelas à 30°

n=length(interM1D30[,1])
m=length(interM2D30[,1])
l=n+m
wh=0
ph=1
zh=c(interM1D30[,2],interM2D30[,1])
zh=sort(zh)
interM2D30[,1] = sort(interM2D30[,1])

for(i in 1:l){
   
  if (zh[i]==interM2D30[,1][ph] && ph<=length(interM2D30[,1])){
    ph=ph+1
    
  }
 
  else{
    wh=wh+i
  }
  
}

z=c(interM1D30[,1],interM2D30[,2])
z=sort(z)
interM1D30[,1]=sort(interM1D30[,1])
w=0
q=1
for(j in 1:l){{
  
  if (interM1D30[,1][q]==z[j] && q<=length(interM1D30[,1])){
    q=q+1
    w=w+j
  }
  }
}

nu=n*(n+m+1)/2
s2=n*m*(n+m+1)/12
tbas=(w-nu)/sqrt(s2)
thaut=(wh-nu)/sqrt(s2)
val=max(thaut,-tbas)
val2=max(0,-thaut,tbas)
pbas=2*(1-pnorm(val))
phaut=2*(1-pnorm(val2))
w
wh
nu
s2
tbas
thaut
val
val2
pbas
phaut
```

```{r}
##test de wilkoxon rank comme sur l'article
X=cbind(c(1,3),c(2,3),c(3,5))
Y=cbind(c(2,3),c(5,5))
n=length(X[1,])
m=length(Y[1,])
l=n+m
wh=0
ph=1
zh=c(X[2,],Y[1,])
zh=sort(zh)
Y[1,] = sort(Y[1,])

for(i in 1:l){
   
  if (zh[i]==Y[1,][ph] && ph<=length(Y[1,])){
    ph=ph+1
    
  }
 
  else{
    wh=wh+i
  }
  
}

z=c(X[1,],Y[2,])
z=sort(z)

w=0
q=1
for(j in 1:l){{
  
  if (X[1,][q]==z[j] && q<=length(X[1,])){
    q=q+1
    w=w+j
  }
  }
}

nu=n*(n+m+1)/2
s2=n*m*(n+m+1)/12
tbas=(w-nu)/sqrt(s2)
thaut=(wh-nu)/sqrt(s2)
val=max(thaut,-tbas)
val2=max(0,-thaut,tbas)
pbas=2*(1-pnorm(val))
phaut=2*(1-pnorm(val2))
w
wh
nu
s2
tbas
thaut
val
val2
pbas
phaut

```

```{r}
##Wilcoxon signed rank de  .Vaidyanathan1  pour trapèze
#mais il y avait un probleme avec positif et negatif et on a envoyé un mail
#on calcul la difference entre deux trapèzes
difference<- function(l,m){
  d=c((l[1]-m[4]),(l[2]-m[3]),(l[3]-m[2]),(l[4]-m[1]))
  return(d)
  }
#on observe si le trapeze est positif ou negatif
isPositif<- function(l){
  if(l[1]>0){
    return(TRUE)
  }
}
isNegatif<- function(l){
  if(l[4]<0){
    return(TRUE)
  }
}
#on calcul la moyenne pour pouvoir ordonner les différences
wilkoxonTest<- function(t,u){
  diff=c()
  moyenne=c()
  for (i in 1:length(t[,1])){
    diff=cbind(diff,difference(t[i,],u[i,]))#on calcule la différence entre deux trapèze
    
  }
  diff=t(diff)
  
  for (i in 1:length(t[,1])){
    moyenne=c(moyenne,mean(diff[i,]))#on classe les différences en calculant la moyenne
  }
  rang=c()
  mo=sort(moyenne)
  for (i in 1:length(moyenne)){
    rang=c(rang,which(mo==moyenne[i]))
  }
  tableau=cbind(diff,moyenne,rang)
 
  sm=sum(rang[moyenne<0])
  sp=sum(rang[moyenne>0])
  s=min(sp,sm)
  n=length(moyenne)
  sigma=n*(n+1)*(2*n+1)/24
  pvalue= pnorm((s-n*(n+1)/4)/sqrt(sigma))
  return(pvalue)
  
}

wilkoxonTest(trapezematelas1D0,trapezematelas2D0)
wilkoxonTest(trapezematelas1D30,trapezematelas2D30)
```



```{r}
##wilkoxon signed test
##Fuzzy Sign test for imprecise quantities for triangular fuzzy data:Pvalue approch
#On calcul à quel point a est supérieur à b
superieur<- function(a,b){
  if(b[3]<=a[1]){
    return(1)
  }
  else if (b[3]>a[1]){
    return((b[3]-2*b[2]+((b[3]*(a[2]-a[1])+a[1]*(b[3]-b[2]))/(a[2]-a[1]+b[3]-b[2])))/(2*(b[3]-b[2])))
    
  }
  
  
}
#calcul la différence de 2 triangles
differencet<- function(l,m){
  d=c((l[1]-m[3]),(l[2]-m[2]),(l[3]-m[1]))
  return(d)
}
teste<- function(u,v){
  supe=c()
  
  for(i in 1:length(u[,1])){
  supe=c(supe,superieur(u[i,],v[i,]))#on met toutes les valeurs de supériorité pour chaque paire de valeur
  }
  
  g=c()
  listealpha=seq(0.5,1,0.001)#on créer plusieurs valeurs de alpha entre 0.5 et 1
  for(i in 1:length(listealpha)){
  tr=supe[supe>listealpha[i]]#on prend toutes les valeur de supériorité qui sont supérieur à alpha
  g=c(g,length(tr)) #on ajoute dans une liste le nombre d'élément supérieur à ce alpha
  
  }
  f0=min(g)
  f1=max(g)
  pbas=0
  #on calcul pbas et phaut avec le binome
  for (i in 0:f0){
    
    pbas=pbas+choose(length(u[,1]),i)*(0.5)**(length(u[,1]))
  }
  phaut=0
   for (i in 0:f1){
     
    phaut=phaut+choose(length(u[,1]),i)*(0.5)**(length(u[,1]))
   }
  
  return(c(pbas,phaut))
  
}
#on choisis un degrés de précision delta et acceptance calcul à quel point l'Hypoyhèse H0est rejeté
acceptance<- function(u,v,delta){
  interpvalue=teste(u,v)
  if(delta<=min(interpvalue)){
    return( 0)
  }
  else if (min(interpvalue)<delta && delta<=max(interpvalue)){
    return((delta-min(interpvalue))/(max(interpvalue)-min(interpvalue)))
  }
  else if (max(interpvalue)<delta && delta<=1){
    return(1)
  }
}
teste(trianglematelas2D0,trianglematelas1D0)
teste(trianglematelas2D30,trianglematelas1D30)

```

```{r}
#triangle
##rank wilcoxon man witney de HESMIAN comme dans l'article
A1=c(51 , 57 , 60 ,1)#on rajoute un 1 pour spécifier que ces données proviennent du première échantillon
A2=c(38 , 44 , 47 ,1)
A3=c(59 , 60 , 60,1)
A4=c(40 , 44 , 49 ,1)
A5=c(34 , 39 , 43 ,1)
A6=c(60 , 60 , 60 ,1)
A7=c(35 , 44 , 50 ,1)
B1=c (55 , 58 , 58 ,0)#et un 0 == elles proviennent du deuxième
B2=c(45 , 45 , 45 ,0)
B3=c(45 , 50 , 55 ,0)
B4=c(47 , 54 , 57 ,0)
B5=c(42 , 49 , 56 ,0)
B6=c(32 , 39 , 45 ,0)
B7=c(50 , 50 , 50,0)
B8=c (42 , 51 , 58 ,0)
A=cbind(A1,A2,A3,A4,A5,A6,A7,B1,B2,B3,B4,B5,B6,B7,B8)
#on calcul l'optimistic value pour un alpha donné
opti <- function(l,alpha){
if (alpha<=0.5){
  return(l[3]+2*alpha*(l[2]-l[3]))
}
else{
  return(2*alpha*(l[1]-l[2])-(l[1]-2*l[2]))
}
}
#on regarde si l>m (2 triengles)
compare<- function(l,m,alpha){
  if(opti(l,alpha)>=opti(m,alpha)){
    return(TRUE)
  }
  else {
    return(FALSE)
  }
  
} 


#fonction qui trie une liste de triangle
tri<- function(A,alpha){
  for(k in 2:length(A[1,])){
    temp=A[,k]
    j=k
    while((j>1) && (!(compare(temp,A[,j-1],alpha)))){
      A[,j]=A[,j-1]
      j=j-1
      
    }
  A[,j]=temp
    }
return(A)
}
#fonction qui somme les rangs des données triés qui proviennent de l'échantillon 1
somme<- function(t){
  s=0
  for (i in 1:length(t[1,])){
    s=s+i*t[,i][4]
    
  }
  return(s)
}
f=c()
listealpha=seq(0,1,0.0001)#pour tous les alpha entre 0et 1
for(i in 1:length(listealpha)){
  tr=tri(A,listealpha[i]) #ON trri selon alpha
  f=c(f,somme(tr))#zt on somme les rang et on les ajoutes dans une liste
  
  
}
#mais je n'arrive pas a comprendre pourquoi mais je trouve des valeurs différents que celles dans l'article on devrait trouver 55 et 62
max(f)
min(f)

```

```{r}
##kolmogorov smirnov
p_box <- function(data, data2, data3, data4) {
  
  # C'est une fonction qui nous permet de tracer les F_A(x) 
  
  result <- sort(c(data,data2,data3,data4))
  result <- cbind(result, rep(0,length(result)))
  n = length(data)
  current_value <- 0
  last_value <- 0
  for (k in 1:nrow(result)) {
    if (result[k,1] %in% data && result[k,1] != last_value) {
      current_value = current_value + 1
    }
     result[k,2] <- current_value/n
    last_value <- result[k,1]
  }
  return(result)
}


interval_KS <- function(x,y) { 
  # interval ks selon https://hal.archives-ouvertes.fr/hal-01045013/document
  # x et y sont deux df avec deux colonnes
  
  x <- t(apply(x,1,sort))
  y <- t(apply(y,1,sort))
  
  sup_x <- sort(x[,1])
  inf_x <- sort(x[,2])
  sup_y <- sort(y[,1])
  inf_y <- sort(y[,2])
  
  f_sup_x <- p_box(sup_x,inf_y,sup_y,inf_x)
  f_inf_x <- p_box(inf_y,sup_x,sup_y,inf_x)
  f_sup_y <- p_box(sup_y,inf_x,sup_x,inf_y)
  f_inf_y <- p_box(inf_x,sup_y,sup_x,inf_y)
  
  high <- max(max(abs(f_sup_x[,2] - f_inf_y[,2])),max(abs(f_inf_x[,2] - f_sup_y[,2])))
  D <- c()
  for (k in 1:nrow(f_sup_x)) {
    if ((f_inf_x[k,2] > f_inf_y[k,2] && f_sup_x[k,2] > f_inf_y[k,2]) || (f_inf_x[k,2] < f_inf_y[k,2] && f_inf_x[k,2] < f_sup_y[k,2])) {
      
      D <- c(D,0)
    } else {
      D <- c(D,min(abs(f_inf_x[k,2]-f_sup_y[k,2]),abs(f_inf_y[k,2]-f_sup_x[k,2])))
                   
    }
    
  }
  low <- max(D)
  return(list("low" = low, "high" = high))
}
interval_KS(interM2D30,interM1D30)
interval_KS(interM2D0,interM1D0)
```



```{r}
##A generalization of the Wilcoxon signed-rank test and its applications



#fonction qui calcul l'alphacut pour des données trapezoidale
alphacut<- function(t,alpha){
  return(c(((t[2]-t[1])*alpha+t[1]),(t[4]-(t[4]-t[3])*alpha)))
}
#on calcul la difference entre le minimum de l'alphacut d'un triangle et le maximum de l'alphacut d'un autre triangle
gldiff<- function(t1,t2,alpha){
  return(min(alphacut(t1,alpha))-max(alphacut(t2,alpha)))
  
  
}
#on calcul la difference entre le minimum de l'alphacut d'un triangle et le maximum de l'alphacut d'un autre triangle mais dans l'autre sens que gldiff
gudiff<- function(t1,t2,alpha){
  return(max(alphacut(t1,alpha))-min(alphacut(t2,alpha)))
  
}
gl<- function(liste1,liste2,alpha){
  listegldiff=c()
  for (i in 1:length(liste1[,1])){#on calcul la difference pour deux listes de triangle
    listegldiff=c(listegldiff,gldiff(liste1[i,],liste2[i,],alpha))
    
  }
  rang=c()
  mo=sort(listegldiff) #on tri les différence
  for (i in 1:length(listegldiff)){
    rang=c(rang,which(mo==listegldiff[i]))#on donne le rang de chaque différence
  }
  tableau=cbind(listegldiff,rang)
  sp=sum(rang[listegldiff>0])#on fait la somme de tous les rangs dont la différence est positive
  return(sp)
}
gu<- function(liste1,liste2,alpha){#on fait pareil que gl mais avec la fonction gudiff
  listegudiff=c()
  for (i in 1:length(liste1[,1])){
    listegudiff=c(listegudiff,gudiff(liste1[i,],liste2[i,],alpha))
    
  }
  rang=c()
  mo=sort(listegudiff)
  for (i in 1:length(listegudiff)){
    rang=c(rang,which(mo==listegudiff[i]))
  }
  tableau=cbind(listegudiff,rang)
  sp=sum(rang[listegudiff>0])
  return(sp)
}
Tl<- function(liste1,liste2,alpha){
  listebeta=seq(alpha,1,0.01)#pour tous les betas superieur à alpha
  listegl=c()
  listegu=c()
  for(i in 1:length(listebeta)){
    listegl=c(listegl,gl(liste1,liste2,listebeta[i]))
    listegu=c(listegu,gu(liste1,liste2,listebeta[i]))
  
  }
  
  return(min(min(listegl),min(listegu)))
  
}
Tu<- function(liste1,liste2,alpha){
  listebeta=seq(alpha,1,0.01)#pour tous les betas superieur à alpha
  listegl=c()
  listegu=c()
  for(i in 1:length(listebeta)){
    listegl=c(listegl,gl(liste1,liste2,listebeta[i]))
    listegu=c(listegu,gu(liste1,liste2,listebeta[i]))
  
  }
 
  return( max(max(listegl),max(listegu)))
  
}
nutplus<- function(liste1,liste2,t){
  listealpha=seq(0,1,0.01)
  listenu=c()
  for (i in 1:length(listealpha)){
    a=seq(Tl(liste1,liste2,listealpha[i]),Tu(liste1,liste2,listealpha[i]))
    if(min(a)<=t && t<=max(a)){
      listenu=c(listenu,listealpha[i])
    }
    
    
  }
  if(is.null(listenu)){#car max d'une liste vide donne moins l'infini
    return(0)

  }
  else{
  return(max(listenu))
  }

}
calaculnutpluspourtousT<- function(liste1,liste2){
listenutplus=c()
n=length(liste1[,1])
listet=seq(1,n*(n+1)/2)
t=c()
for(i in 1:length(listet)){
  listenutplus=c(listenutplus,nutplus(liste1,liste2,listet[i]))
  t=c(t,i)
  
}
return(cbind(listenutplus,t))
}
#nutplus(trapezematelas1D0,trapezematelas2D0,1485)
nutplus(trapezematelas1D30,trapezematelas2D30,1431)





```

```{r}
cdelta<- function(liste1,liste2,delta){
#calcul de Cdelta
n=length(liste1[,1])
#on observe si liste1-liste2<0
t=0
z=(t-(n*(n+1)/4)-0.5)/(sqrt((2*n*(n+1)*(2*n+1))/48))
listet=seq(1,n*(n+1)/2)
max=0
for (i in  1:length(listet)){

t=listet[i]
if(pnorm(z)<delta){
  max=t
  
  
}
}

return(max)

}
cdelta(trapezematelas1D0,trapezematelas2D0,0.05)
cdelta(trapezematelas1D30,trapezematelas2D30,0.05)
```

```{r}
n=53
z=(t-(n*(n+1)/4)-0.5)/(sqrt((2*n*(n+1)*(2*n+1))/48))
t=100
pnorm(z)
```



Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Ctrl+Alt+I*.

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Ctrl+Shift+K* to preview the HTML file).

The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike *Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.
